---
title: Совсем другая книга про Go
---

# Совсем другая книга про Go
## Введение

"Маленькие книги" Карла Сегуина – лучшие в жанре "быстрого старта". В них ничего лишнего, только самое главное. Подробности, в которых так легко утонуть поначалу, потом так же легко восполнить правильными вопросами и самостоятельно найденными ответами.

Когда-то "Маленькая книга про Go" вдохновила меня написать несколько других "маленьких книг" на темы, для которых книг Карла не было. А потом, когда я сам пришел к Go и вернулся к этой книге, вдруг оказалось, что демонстрационные примеры еще работают, а вот что-то реальное написать уже не получается. Как же так получилось?

Все меняется, иногда – радикально. Модули в обновленном Go настолько отличаются от прежних, что написать что-то сложнее HelloWorld становится почти невозможно. Но, начав однажды писать, я не смог остановится и решил во всем этом разобраться и записать. Подробные записи всегда делаются для себя, но я надеюсь, пользу они принесут не только мне. 

Это будет совсем другая книга про Go. Не судите строго.

## Инструменты

### Команда Go

Это официальное название. Одна-единственная "команда go" используется для компиляции, выполнения, тестирования, управления зависимостями, форматирования исходного кода… для всего.  Настоящий "швейцарский нож", осваивать который лучше постепенно.

### Среда разработки

vi, nano, notepad – у каждого программиста есть свой любимый инструмент для написания исходного кода. А еще есть интегрированные среды разработки (IDE) вроде платного Goland от JetBrains или свободного VSCode от Microsoft. Выбор есть всегда, но если вы его еще не сделали, посмотрите в сторону последнего. В VSCode официальная поддержка Go очень неплоха, его возможностей хватит вам очень надолго.

## Первая программа

Пройти все этапы от написания кода до его выполнения – первый урок в изучении любого языка программирования и проверка работоспособности установленных инструментов разработки.

В любом текстовом редакторе создайте файл `hello.go`:

~~~go
package main
import "fmt"

func main() {
    fmt.Println("Hello, world!")
}
~~~

Выполните его:

~~~bash
$ go run hello.go
Hello, world!
~~~

Или скомпилируйте и выполните:

~~~bash
$ go build hello.go
$ ./hello
Hello, world!
~~~

А еще вы можете все то же самое сделать в VSCode. Просто, чтобы попрактиковаться.

## Функции

Можно написать программу полностью, от начала и до конца. Но зачем нам это, если некоторые задачи уже решены и мы может просто этим воспользоваться. К примеру, в нашей первой программе выводим приветственное сообщение, не особенно вникая, как это происходит.

А происходит вот что. Функция `Println` выводит нужную строку на экран, избавляя нас от необходимости разбираться, какие системные вызовы для этого использовать, как операционная система взаимодействует с драйверами и как драйверы формируют на экране монитора нужное изображение. И так во всем, стандартная библиотека содержит множество функций высокого уровня, которые мы и вызываем в своей программе.

Функции так называются из-за того, что получают на вход аргументы и возвращают результат, хотя в отличие от математических функций могут не только вычислять возвращаемое значение, но и делать какие-то другие действия. 

## Модули

Функции произвольно (на самом деле тематически) сгруппированы по модулям, которые являются вторым элементов декомпозиции. В Go все состоит из модулей. Одни из них входят в стандартную библиотеку, другие – ваши собственные, третьи написаны кем-то еще. 







## Декомпозиция

Это и есть декомпозиция – разбиение задачи на более простые, часть из которых уже решены. Функции являются одним из двух элементов декомпозиции. Они так называются из-за того, что получают на вход аргументы и возвращают результат, хотя в отличие от математических функций могут не только вычислять возвращаемое значение, но и делать какие-то другие действия. 



## Модули

Любая программа на Go состоит из модулей. Модуль это основая (точнее, единственная) единица декомпозиции. А декомпозиция, как мы знаем, это способ разделения на части.



 Одним модулям для работы нужны другие модули, им, в свою очередь, нужны еще какие-то и так далее. В итоге программа собирается из модулей, которые все вместе образуют дерево зависимостей, на самом верху которого находится модуль `main` с функцией `main`. Это особенный модуль и особенная функция – в собранной программе будут все модули из дерева зависимостей, но выполнение программы начнется именно с этой функции этого модуля.

> Такие сущности называются "магическими", потому что особые свойства им придают их особые имена.









Создадим директорию для нашей программы и перейдем в нее:

~~~
$ mkdir myDemoProject
$ cd myDemoProject
~~~

Затем инициализируем наш новый модуль:

~~~
$ go mod init DEMOD
~~~

Имя модуля – отсылка к вселенной комиксов Marvel. Если оно вам незнакомо – просто забейте. Важно то, что исполнимый файл после создания будет называться именно так.

В итоге будет создан файл с вот таким содержанием:

~~~
module DEMOD

go 1.24.3
~~~

1.24.3 – текущая версия Go, установленная на моем компьютере на момент написания этих строк. Она может (и, наверняка, будет) отличаться.

Скопируйте сюда нашу первую программу `helloworld.go`, затем соберите и запустите ее:

~~~
$ go build
$ ./DEMOD
Hello, world!
~~~

Все точно так же, да. Но теперь мы создали модуль DEMOD, а в нем – модуль `main`. И не просто выполнили программу, а создали исполняемый файл, который можно запустить не только здесь, где у вас установлена среда разработки, а на любом другом компьютере с такой же операционной системой, что и у вас.

> Здесь замечу, что в любой поддерживаемой операционной системе можно создать исполнимый файл для любой другой, но это тоже деталь, о которой сейчас не время говорить.

##— 

## Переменные

### Области видимости

### Время жизни

## Типы данных

### Базовые

### Композитные (составные)

### Функции

## Управление потоком

### Декомпозиция

### Ветвление

### Циклы