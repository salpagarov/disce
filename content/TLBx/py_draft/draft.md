## Объекты

> Все есть число
> – Пифагор

В Python объектами является все. И числа тоже.

Объект - это абстрактная философская сущность, у которой есть состояние и поведение. Состояние объекта это набор его свойств, поведение объекта это набор его методов.

Однако, прочь философию. Но и на уровень микропроцессоров и интегральных схем мы тоже опускаться не будем. Достаточным уровнем абстракции для нас будет описание объекта, как сущности со своим внутренним представлением (неважно, каким) и набором методов.







Объект объекту рознь, но мы знаем, что числа можно складывать и перемножать. Это значит, что поведение чисел (набор их методов) уже где-то задан, даже если самих чисел еще не существует. То есть где-то существует абстрактный объект "число", для которого определены методы "сложить" и "умножить", и есть конкретные числа `2` и `3`, к которым этим методы применимы. Абстрактный объект называется классом, в конкретные объекты являются экземплярами этого класса. Когда создаются экземпляры класса, они сразу же наследуют все его методы.

А еще у классов есть иерархия. Это как в биологии - мы знаем, что волк и собака принадлежат разным видам, но мы также знаем, что собака ближе к волку, чем к кошке. Потому что виды "волк" и "собака" относятся к семейству "волчьих", а кошка - к семейству "кошачьих". При этом все они - и волки, и собаки, и кошки - входят в отряд "хищных", то есть всем им свойственно поведение хищников.

В Python в иерархию классов входят все типы данных - и встроенные, и созданные программистом для своих нужд. Но об этом позже (все-таки пришлось использовать этот оборот, извините).

Дочерние классы наследуют поведение от родительского, но могут их изменить или дополнить.











## Типы данных

По большому счету, любая программа занимается получением, обработкой и выводом данных. Поэтому, инструкции языков программирования обычно изучают после типов данных.

### Логические значения

Их всего два: "истина" и "ложь", записываются словами `True` и `False` соответственно. Именно так, с большой буквы.

~~~python
>>> True            # "истина"
True
>>> False           # "ложное"
False
>>> not True        # НЕ "истина" означает "ложь"
False
>>> True and False  # "истину" И "ложь" одновременно невозможны
False
>>> True or False   # "истина" ИЛИ "ложь" соответствуют действительности
True
~~~

Истинным или ложным могут быть не только логические значения.  `False` это ещё и нуль, пустые строки, списки, множества. `True` - все остальное. А еще истинным или ложным может быть результат сравнения данных любых других типов.

### Целые числа

Целые числа состоят из цифр и, если нужно, знака "минус" (целые - они не только натуральные бывают, но и отрицательные тоже). Они могут быть очень большими, в Python на радость любителям астрономии и криптографии реализована "длинная арифметика".

Для целых чисел доступны операции сложения (`+`), вычитания (`-`), умножения (`*`), возведения в степень (`**`), целочисленное деление (`//`) и остаток от деления (`%`). Настоящее ("истинное") деление может дать результат с дробной частью, а радости длинной арифметики на вещественные значения не распространяются.

~~~python
>>> 2**2048     # целые числа могут быть любого размера (** это знак операции возведения в степень)
32317006071311007300714876688669951960444102669715484032130345427524655138867890893197201411522913463688717960921898019494119559150490921095088152386448283120630877367300996091750197750389652106796057638384067568276792218642619756161838094338476170470581645852036305042887575891541065808607552399123930385521914333389668342420684974786564569494856176035326322058077805659331026192708460314150258592864177116725943603718461857357598351152301645904403697613233287231227125684710820209725157101726931323469678542580656697935045997268352998638215525166389437335543602135433229604645318478604952148193555853611059596230656
>>> 2**2048/2  # операция "истинного" деления выполняет преобразование к вещественному типу, а его может и не хватить
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
OverflowError: integer division result too large for a float
>>> 2**2048//2 # для этого существует целочисленное деление
16158503035655503650357438344334975980222051334857742016065172713762327569433945446598600705761456731844358980460949009747059779575245460547544076193224141560315438683650498045875098875194826053398028819192033784138396109321309878080919047169238085235290822926018152521443787945770532904303776199561965192760957166694834171210342487393282284747428088017663161029038902829665513096354230157075129296432088558362971801859230928678799175576150822952201848806616643615613562842355410104862578550863465661734839271290328348967522998634176499319107762583194718667771801067716614802322659239302476074096777926805529798115328
~~~

К целым числам применимы операции битового сдвига.

~~~python
>>> 16>>3      # это все равно, что 16//2**3
2
>>> 16<<3      # равносильно 16*2**3
128
~~~

(если вы не знакомы с двоичной математикой - возможно, стоит ознакомиться)

Применимы к числам и логические операции, но с ними все несколько веселее.

~~~python
>>> not 0      # нулевое значение ложно, все остальные истинны
True
>>> 3 or 4     # если первое значение истинно, оно и возвращается (без преобразования)
3
>>> 3 and 4    # если истинны оба значения, возвращается второе (и тоже без преобразования)
4
~~~

Логика странная, но - есть.

#### Системы счисления

Все числа до сих пор были в позиционной десятичной системе счисления. 

Десятичная система счисления ведет свое происхождение от счета на пальцах, у трехруких шестипалых в ходу была бы восемнадцатиричная система. Но мы, люди, по вполне очевидным причинам используем десятичную систему счисления из десяти "арабских" цифр (в кавычках потому, что в современном арабском языке цифры совсем другие). 

А позиционная она потому, что в зависимости от места в числе ее "вес" отличается. `132` и `312` это разные числа, хотя и содержат одинаковые цифры. Потому, что 132 это 2x10^0^ + 3x10^1^ + 1x10^2^, а 312 это 2x10^0^ + 1x10^1^ + 2x10^2^.

В привычной нам позиционной десятичной системе счисления основанием системы является 10 (количество пальцев на руке), а разряды (то, что называется "десятками", "сотнями" и "тысячами") считаются справа налево ("по-арабски").

Но это не единственный способ представления чисел. Для электронного вычислителя, который оперирует электрическими импульсами, используется двоичная система счисления ("есть напряжение", "нет напряжения") с цифрами 0 и 1.

~~~python
>>> 0b0101010    # если число начинается с 0b, то оно в двоичной системе (от "binary" - "двоичное")
42
>>> 0o52         # если с 0o, то в восьмеричной ("octal")
42
>> 0x2a          # а если с 0x - в шестнадцатеричное ("hexadecimal")
42
~~~

Восьмеричная и шестнадцатеричная система счисления отличаются лишь основанием (соотвественно 8 и 16) и набором цифр - в восьмеричной системе не используется 8 (после 7 идет 10), а в шестнадцатеричной в качестве "дополнительных" цифр используются латинские буквы (`A` - 10, `B` - 11, `C` - 12, `D` - 13, `E` - 14 и `F` - 15). 

Отличается лишь форма записи, числа остаются теми же самыми. Просто иногда это удобнее.

### Вещественные числа

Вещественные числа аналогичны double из Си и занимают 64 бита. Все операции, применимые к целым и логическим значениям, работают и тут. Но, как говориться, "есть нюансы"…

~~~python
>>> 2.0 * 2    # даже если дробная часть равна нулю, оно присуствует
4.0
>>> 4/1        # результат операции "истинного" деления (не целочисленного) всегда вещественный
4.0
>>> 5.0//2     # целочисленное деление отбрасывает дробную часть, но преобразования типов не производит
2.0
>>> 0.2 + 0.2  # здесь все нормально
0.4
>>> 0.2 + 0.2 + 0.2       # WTF?!
0.6000000000000001
>>> 0.2 + 0.2 + 0.2 + 0.2 # а здесь снова все хорошо
0.8
~~~

Если вы не хотите погружаться в математический аппарат чисел с "плавающей запятой" со его проблемами и особенностями, просто запомните, что вещественные числа штука ненадежная и их лучше избегать. Например, так:

~~~python
>>> (2+2+2)/10 # но и это не гарантирует от ошибки
0.6
~~~

#### Экспоненциальная форма

Вещественные числа могут записываться в экспоненциальной форме (внутреннее представление числе с "плавающей запятой" именно такое).

~~~python
>>> 6e-1        # это должно означать 6*10**(-1)
0.6
>>> 6*10**(-1)  # "...но это не точно"
0.6000000000000001
~~~

И - да, в контексте вещественных чисел "точка" и "запятая" это синонимы. Просто математики говорят "запятая", а в программировании для этого используется точка. Просто имейте в виду. 

### Комплексные числа

Они тоже реализованы прямо в интерпретаторе и мне это кажется излишним. Но - что есть, то есть.

~~~python
>>> 5j          # это мнимое число
5j
>>> 2+5j        # это комплексное число с действительной и мнимой частью
(2,5j)
>>> 2+5j*2      # арифметика работает
(2+10j)
>>> (2+5j)*2    # надо только правильно ставить скобки
(4+10j)
>>> (2+5j)/2    # комплексные числа могут быть и дробными
(1+2.5j)
~~~

### Строки

~~~python
>>> "Hello, world"  # одиночные и двойные кавычки полностью равноправны
'Hello, world'
>>> 'Hello, "Brave New World"'  # можно спокойно использовать одни внутри других
'Hello, "Brave New World"'
~~~

Есть еще и "тройные" кавычки. Нет, это не специальный символ, это три символа кавычек подряд.

~~~python
>>> '''Hello'''   # тройные кавычки
'hello'
>>> """Hello"""   # тройные двойные кавычки, как бы идиотски это ни звучало
'hello'
~~~

А нужно это для того, чтобы записывать многострочные строки (еще один оксюморон!). Хотя на самом деле все просто - если вам нужно, чтобы многострочный текст помещался в одну переменную - используйте "тройные" кавычки (одиночные или двойные) в начале и конце текста, не думая о разрывах строк в середине.

Впрочем, экранирование символов (при помощи символа `\`) тоже присутствует.

~~~python
>>> "Oh, hello Dolly\nWell, hello Dolly" # это две строчки из песни
'Oh, hello Dolly\nWell, hello Dolly'
>>> 'It\'s so nice to have you back where you belong' # кавычки можно экранировать и так
"It's so nice to have you back where you belong"
>>> "hello\rH" # и так далее...
"hello\rH"
>>> print ("hello\rH") # попробуйте разобраться сами, что здесь произошло и почему
Hello
>>> "1" + "1"          # никаких сюрпризов, сложение строк это их объединение ("конкатенация")
'11'
>>> "ha" * 3           # слегка необычная операция, но тоже интуитивно понятная
'hahaha'
~~~

### Списки

В других языках эта структура может еще называться массивом.

~~~python
>>> []                   # список может быть пустым
[]
>>> ['one',[21,22],3.0]  # может содержать данные любого типа, влючая другие списки
['one', [21, 22], 3.0]
>>> [1,2,3][1]           # доступ к элементам осуществляется по индексу (начиная с 0)
2
>>> [1,2,3,4][4]         # но только к существующим, чтобы не получить ошибку
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
>>> [1,2,3,4][1:2]       # это срез
[2, 3]
>>> [1,2,3,4][:2]        # срез без левой границы
[1, 2, 3]
>>> [1,2,3,4][1:]        # срез без правой границы
[2, 3, 4]
>>> [1,2,3,4][:]         # срез без границ (то есть весь список)
[1, 2, 3, 4]
>>> [1,2,3] + [4,5,6]    # сложение списков
[1, 2, 3, 4, 5, 6]
>>> [1,2,3] * 2          # умножение списка на число
[1, 2, 3, 1, 2, 3]
~~~

Срезы можно присваивать.

~~~python
>>> a = [1,2,3,4]
>>> a[1:2] = ['second',0,'3rd']  # срезы можно присваивать
>>> a
[1, 'secons', 0, '3rd', 3, 4]
~~~

Если вам кажется, что многое упущено - вы правы. Но наберитесь терпения, скоро все потерянное найдется.

### Кортежи

Кортеж это такой список. Ну, почти…

~~~python
>>> b = (1,2,3)
>>> b
(1,2,3)
>>> b[1] = 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
~~~

Изменить содержимое кортежа нельзя. Вся разница. Не считая, конечно, круглых скобок вместо квадратных.

### Словари

Словарь это то, что в других языках называется ассоциативным массивом (или хэш-таблицей).

~~~python
>>> D = {'food': 'Spam', 'quantity': 4, 'color': 'pink'}
>>> D['food']
'Spam'
>>> D['quantity'] += 1  # содержимое словарей можно менять
>>> D['name'] = "Sol"
>>> D
{'food': 'Spam', 'color': 'pink', 'quantity': 5, 'name' : 'Sol'}
~~~

В отличие от списка и кортежа, складывать словари и умножать их на число нельзя.

(мы ведь договорились немного подождать?)

### Множества

Множество словарь с ключами, но без значений.

~~~python
>>> a = {'mercury', 'venus', 'earth', 'mars'}
>>> a
{'mercury', 'venus', 'earth', 'mars'}
~~~

Множества нельзя складывать, умножать на число, добавлять новые элементы.

(осталось совсем немного)

## Объекты

> И молвил Морж: "Пришла пора поговорить о многом" 
> – Льюис Кэрролл.

Объект вообще - абстрактная философская сущность, у которой есть состояние (набор свойств) и поведение (набор методов). 

## Классы

Объект объекту рознь, но мы знаем, что числа можно складывать и перемножать. Это значит, что поведение чисел (набор их методов) уже где-то задан, даже если самих чисел еще не существует. То есть где-то существует абстрактный объект "число", для которого определены методы "сложить" и "умножить", и есть конкретные числа `2` и `3`, к которым этим методы применимы. Абстрактный объект называется классом, в конкретные объекты являются экземплярами этого класса.

А еще у классов есть иерархия. Это как в биологии. Мы знаем, что волк и собака принадлежат разным видам, но мы также знаем, что собака ближе к волку, чем к кошке. Потому что виды "волк" и "собака" относятся к семейству "волчьих", а кошка - к семейству "кошачьих". При этом все они - и волки, и собаки, и кошки - входят в отряд "хищных", то есть всем им свойственно поведение хищников.

Так и здесь. В Python в иерархию классов входят все типы данных - как встроенные, так и созданные программистом для своих нужд. Но об этом позже (все-таки пришлось использовать этот оборот, извините).

## Выражения

> Fallaces sunt rerum species (лат.: "все не то, чем кажется")

Вот тут начинается самое интересное. Дело в том, что в Python нет базовых классов и все описанное в типах данных - это тоже объекты.

Взгляните:

~~~python
>>> int(2).__add__(int(2).__mul__(int(2)))
6
~~~

Это то же самое, что и `2+2*2`.

Что же касается выражений - в том виде, в каком они есть в математике и других языках программирования - то их нет. Нет операции сложения, которая получает два операнда слева и справа от знака операции и возвращает их сумму. И умножения нет. Ничего нет. Есть только методы у объектов, которые получает другой объект и возвращает сумму (ну, или произведение) своего значения с полученным.

А то, что мы можем написать классическое `2+2*2` и получить ответ `6`, с учетом привычных приоритетов операций, всего лишь семантический сахар.

## Семантический сахар

Семантическим сахаром называется упрощенная запись каких-то действий, сделанная для удобства и читаемости. Нет никакой разницы, напишите вы `int(2).__add__(int(2))` или `2+2`, интерпретатор будет делать одно и то же. Кроме, конечно, эстетической, второй вариант проще и понятней.

А то, что знак `+` превращается в вызов метода `__add__`  это магия. 

## Магия

> "Как вы лодку назовете, так она и поплывет" ("Приключения капитана Врунгеля", Киевнаучфильм, 1979)

В языках программирования магическими принято считать элементы, поведение которых зависит от того, как они называются. Например, для того, чтобы числа можно было складывать (использовать знак `+`), необходимо наличие метода `__add__ `(с двумя знаками подчеркивания в на чале и в конце). Только в этом случае интерпретатор поймет, какой метод класса надо вызвать. 

Этому нет никакого логического объяснения, кроме "потому что". Так оно было спроектировано автором языка и называются "магическим" в том числе и поэтому.

## Литералы

> Мы говорим "Ленин", подразумеваем - "партия",
> Мы говорим "партия", подразумеваем - "Ленин" (Владимир Маяковский)

Итак, мы пишем `2`, а интерпретатор создает объект "целое число" и сохраняет в нем `2`. Но как он узнает, что это целое число? А очень просто: целое число состоит из цифр, дробное - содержит еще десятичную точку, и так далее. Это литералы, форма записей которых однозначно дает понять интерпретатору, какого класса описываемые им данные.

Если литерал определяет какого класса получившийся объект, то класс определяет его поведение - тот самый набор методов. То, что все числа можно складывать, умножать и так далее, означает, что их класс определяет методы для сложения, умножения и остальных операций. Которых может не быть, например, у строки.

## Переменные

Переменная это "ярлычок", привязанные к данным в памяти. Не "именованная область памяти", по нее не выделяется память для хранения. Просто имя, с которым сохраненное значение связывается. Есть оно - значение хранится, нет - уничтожается сборщиком мусора. Поэтому нет никакой необходимости следить, чтобы в создаваемой переменной "хватало места" для сохраняемого значения - оно сохраняется в памяти как есть, а имя обеспечивает возможность извлечения его их памяти и защищает от удаления. И именно поэтому строки, не связанные с переменными, работат как комментарии - они просто нигде не сохраняются и ни на что не влияют.

Связывание (то, что в других языках называется "присваиванием") значения с именем переменной представляет собой линейное отображение слева направо и записывается при помощи знака `=`, справа от которого располагается литерал или выражение, а слева - имя переменной, с которой надо связать это значение в памяти. Изменить значение переменной нельзя, но можно связать ее с другим значением. При этом прежнее значение переменной уничтожается автоматически.

~~~python
>>> a = 1      # переменные создаются при первом связывании
>>> a = 2      # связывание перемнной с новым значением уничтожает прежнее
>>> a          # при перезаписи прежнее значение уничтожается
2
>>> b = a * 2  # если выражение содержит переменную, то используется связанное с ней значение
>>> z          # чтение несуществующей переменной приводит к ошибке
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'z' is not defined
~~~

Данные могут быть разного типа, но к переменным это не относится - только к их значениям.

## Управление памятью

Для хранения объектов Python использует модель "куча" (англ. heap). Это означает, что для сохранения данных выделяется часть доступной памяти, которая после этого помечается занятой. Сохраненные данные нельзя менять, можно лишь сохранить измененные данный - выделяя для этого новый фрагмент доступной памяти.

Понятно, что при таком подходе память рано или поздно закончится. Ситуация, когда память расходуется и не освобождается, называется "утечкой памяти". Для борьбы существует механизм, называемый "сборщиком мусора". Задача сборщика мусора заключается в уничтожении данных, которые после записи в память нельзя прочесть. Для того, чтобы результат выражения был доступен, он должен быть связан с именем переменной.

## Области видимости

У каждой переменной есть 4 области видимости:

1. Локальные
2. Нелокальные
3. Глобальные
4. Встроенные

## Элементы декомпозиции

## О важности пробелов

Пробелы важны. Представьте себе хорошо отформатированный код на Си. Благодаря отступам программа хорошо читается. Уберите фигурные скобки и сделайте так, чтобы транслятор сам структурировал код по отступам. Так вот, Python именно такой.

А если вспомнить знаменитое "Code is poetry", то Python это стихи Маяковского. Еще одна профессиональная шутка.

## Условия

~~~python
if t > 0 :
    print ("positive")
elif t < 0 : # ветка elif может быть не одна, а может и отсутствовать
    if t < -273.15: # конструкции легко вкладываются, главное - следите за отступами!
        print ("it's impossible")
    else
    	print ("negative")
else: # это тоже необязательная часть
    print ("zero")
~~~

## Цикл while

~~~python
n = 100
while True: # Если вместо условия написать константу, то цикл будет вечным
    n -= 1
    if n < 10:
        break # но его можно прервать
    if n % 3 == 0:
        continue # пропуская в процессе каждый третий элемент
    print (n)
else: 
    # Опционально: 
    # сюда мы попадем в том (гипотетическом в данном примере) случае,
    # если цикл завершится без экстренного выхода по break.
    print ("wft?!")
~~~

## Цикл for

~~~python
for x in ['mon','tue','wed','thu','fri','sat','sun']: # по элементам списка
    print (x)
    
for c in "Alphabet": # по буквам строки
    if c == 'x':
        break
    print (c)
else: # здесь тоже может быть этот необязательный элемент
	print ("no 'x' in word")
~~~

## Функции

~~~python
def do_nothing (): # функция без параметров
    pass           # которая ничего не делает

def say (s, n=1):  # у некоторых аргументов могут быть значения по умолчанию
    return s*n

print(say("ok"))        # такие параметры при вызове можно пропускать
print(say('ha', 3))     # вызовы функций могут быть как с позиционными аругментами...
print(say(n=3, s='ha')) # ... так и с именованными (последовательность не важна)

def print_args(*args) # внутри функции можно получить список аргументов
	print(args)       # это работает только для вызовом с позиционными аргументами!
    
def print_karg(**args): # а можно получить и словарь (с ключами)
    print(args)         # это работает только для вызовом с именованными аргументами!
    
def print_args(a, b, c, *args, z): # все методы можно сочетать
    d, e, f = args                 # но важно знать, сколько аргументов будет
    print(a, b, c, d, e, f, z)

print_args(1, 2, 3, 4, 5, 6, z=7)  # аргументы после *args могут быть только именованные!
~~~

# ! проблема с изменяемыми аргументами (списки, множества) !

# ! yeld !

# ! Замыкания !

# ! Анонимные функции !

# ! Генераторы !

# ! Исключения !

try
except
else
finally

### Готовые исключения

### Собственные исключения

### Порождение исключения

## Объекты

На самом деле, в Python объектами является все - числа, строки, списки, функции. Но это неважно, потому что вмешаться в работу встроенных объектов вы все равно не сможете.

Другое дело, созданные вами объекты.

~~~python
class Robot:
    # свойства объектов можно определять прямо в классе
    description = "robot"
    
    # конструктор, выполняется при создании объекта - экземпляра класса
    def __init__(self, name): # первым параметром всегда передается сам объект
        self.name = name # другой способ определять свойства
        
    def fire(self, *args):
        print("I should not harm a human by action or inaction")


class Car:
    
    def drive(self, destination):
        print("Going to: {}".format(destination))
        
        
class Decepticon(Car, Robot):
    def fire(self, target):
        print("{} will be destroyed!")
~~~

# ! Функции как объекты !

Функции тоже являются объектами.

# ! Декораторы !

"Декоратор" - это шаблон программирования, используемый для дополнения существующей функциональ

# ! Модули !

# ! Пакеты !

# ! Библиотека !